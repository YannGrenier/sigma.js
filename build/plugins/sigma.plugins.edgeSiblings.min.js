(function(undefined){"use strict";function deepCopy(o){var copy=Object.create(null);for(var i in o)"object"==typeof o[i]&&null!==o[i]?copy[i]=deepCopy(o[i]):"function"==typeof o[i]&&null!==o[i]?eval(" copy[i] = "+o[i].toString()):copy[i]=o[i];return copy}function addEdgeSibling(a,b){if(!a.siblings){var c=deepCopy(a);a.siblings={},a.siblings[a.id]=c,delete a.color,delete a.label,a.size=1,a.type="parallel",this.siblingEdgesIndex[c.id]=c}a.siblings[b.id]=b,this.siblingEdgesIndex[b.id]=b}function dropEdgeSibling(a,b){if(delete a.siblings[b],delete this.siblingEdgesIndex[b],1===Object.keys(a.siblings).length){var c=a.siblings[Object.keys(a.siblings)[0]];this.dropEdge(a.id),this.addEdge(c),delete this.siblingEdgesIndex[a.id],delete this.siblingEdgesIndex[c.id]}}if("undefined"==typeof sigma)throw"sigma is not declared";sigma.utils.pkg("sigma.plugins"),sigma.classes.graph.hasMethod("addEdgeSibling")||sigma.classes.graph.addMethod("addEdgeSibling",function(a){if(Object(a)!==a||1!==arguments.length)throw"addEdgeSibling: Wrong arguments.";if("string"!=typeof a.id)throw"The edge must have a string id.";if("string"!=typeof a.source||!this.nodesIndex[a.source])throw"The edge source must have an existing node id.";if("string"!=typeof a.target||!this.nodesIndex[a.target])throw"The edge target must have an existing node id.";if(this.edgesIndex[a.id])throw'The edge "'+a.id+'" already exists.';if(this.siblingEdgesIndex[a.id])throw'The edge sibling "'+a.id+'" already exists.';var b=this.allNeighborsIndex[a.source][a.target];if(b!==undefined&&Object.keys(b).length){var c=this.edges(b[Object.keys(b)[0]].id);addEdgeSibling.call(this,c,a)}else this.addEdge(a)}),sigma.classes.graph.hasMethod("dropEdgeSibling")||sigma.classes.graph.addMethod("dropEdgeSibling",function(a){if("string"!=typeof a||1!==arguments.length)throw"dropEdgeSibling: Wrong arguments.";var b=this.siblingEdgesIndex[a];if(b===undefined)this.dropEdge(a);else{var c=this.allNeighborsIndex[b.source][b.target];if(1===Object.keys(c).length){var d=this.edges(Object.keys(c)[0]);if("parallel"!==d.type)throw'The sibling container must be of type "parallel".';if(d.siblings===undefined)throw'The sibling container has no "siblings" key.';if(Object.keys(d.siblings).length<2)throw"The sibling container must have more than one sibling.";if(d.siblings[a]===undefined)throw"Sibling container found but the edge sibling is missing.";dropEdgeSibling.call(this,d,a)}else{if(!(Object.keys(c).length>1))throw"Edge sibling found but its container is missing.";var e,f=!1;for(e in c){var d=this.edges(e);if(!f&&"parallel"===d.type&&d.siblings!==undefined){if(!Object.keys(d.siblings).length)throw"Edge sibling found but its container is missing.";d.siblings[a]!==undefined&&(f=!0,dropEdgeSibling.call(this,d,a))}}if(!f)throw"Edge sibling found but its container is missing."}}}),sigma.classes.graph.hasMethod("readWithSiblings")||sigma.classes.graph.addMethod("readWithSiblings",function(a){var b,c,d;for(c=a.nodes||[],b=0,d=c.length;d>b;b++)this.addNode(c[b]);for(c=a.edges||[],b=0,d=c.length;d>b;b++)this.addEdgeSibling(c[b]);return this}),sigma.classes.graph.addIndex("siblingEdgesIndex",{constructor:function(){this.siblingEdgesIndex=Object.create(null)}})}).call(this);